// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc2084.CMonster2017;

import org.usfirst.frc2084.CMonster2017.PID.DistancePID;
import org.usfirst.frc2084.CMonster2017.PID.HeadingPID;
import org.usfirst.frc2084.CMonster2017.RobotMap;
import org.usfirst.frc2084.CMonster2017.commands.*;
import edu.wpi.first.wpilibj.CounterBase.EncodingType;
import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.PIDController;
import edu.wpi.first.wpilibj.PIDSourceType;
import edu.wpi.first.wpilibj.Spark;
import edu.wpi.first.wpilibj.SpeedController;
import com.ctre.CANTalon.FeedbackDevice;
import com.ctre.CANTalon.TalonControlMode;
import edu.wpi.first.wpilibj.command.Subsystem;
import com.ctre.*;

import com.kauailabs.navx.frc.AHRS;
import edu.wpi.first.wpilibj.I2C;

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import edu.wpi.first.wpilibj.Compressor;
import edu.wpi.first.wpilibj.DoubleSolenoid;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

/**
 * The RobotMap is a mapping from the ports sensors and actuators are wired into
 * to a variable name. This provides flexibility changing wiring, makes checking
 * the wiring easier and significantly reduces the number of magic numbers
 * floating around.
 */
public class RobotMap {
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    public static Compressor gearBaseCompressor;
    public static DoubleSolenoid gearBasegearSolenoid;
    public static DoubleSolenoid gearBasefloorGearSolenoid;
    public static DoubleSolenoid gearBaserotatGearSolenoid;
    public static DoubleSolenoid climberBaseclimberSolenoid;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

	// autogenerated code declares all the solenoids and the compressor

	public static DistancePID distancePID = new DistancePID(); // PID for
																// distance -
																// makes the
																// robot slow
																// down at the
																// right times,
																// keeps
																// straight
																// course
	
	public static HeadingPID headingPID = new HeadingPID(); // PID for
															// controlling the
															// direction of he
															// robot
	
	public static double AverageDistance; // the average of right and left
											// distance from encoders

	// There are 2 driver motors on each side of the robot.
	// Here are the declarations.
	// public static SpeedController driveBasePIDLeftTalon2;
	// public static SpeedController driveBasePIDRightTanlon2;
	// public static PIDController driveBasePIDLeftPIDController2;
	// public static PIDController driveBasePIDRightPIDController2;

	public static AHRS ahrs; // navX

	public static CANTalon driveBaseLeftTalon1; // main
	public static CANTalon driveBaseRightTalon1; // main
	public static CANTalon driveBaseLeftTalon2; // followers
	public static CANTalon driveBaseRightTalon2; // followers

	public static CANTalon driveBaseClimberTalon; // Talon for the climber
	public static CANTalon lifterTalon; // talon for the climber
	public static CANTalon GearIntakeTalon; //talon that controls motor to intake gear from floor
	
	/**
	 * .0 Wheel diameter in feet.
	 */
	public static final double DRIVE_SUBSYSTEM_WHEEL_DIAMETER = 0.33333333333; 
	//0.3333333 is 1/3 of a foot, or 4 inches (the diameter of the wheels)
	
	public static final double DRIVE_SUBSYSTEM_BELT_RATIO = 1 / 1; // no belt
																	// ratio
	public static final double DISTANCE_PER_PULSE = Math.PI * 0.333333333333; // 1.047166666666
	// pi times the diameter is the circumfrence of the wheel - how far it goes
	// with each rotation

	/**
	 * The navX Micro used for autonomous and aiming
	 */

	public static void init() {
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        gearBaseCompressor = new Compressor(1);
        
        
        gearBasegearSolenoid = new DoubleSolenoid(1, 0, 1);
        LiveWindow.addActuator("GearBase", "gearSolenoid", gearBasegearSolenoid);
        
        gearBasefloorGearSolenoid = new DoubleSolenoid(1, 6, 7);
        LiveWindow.addActuator("GearBase", "floorGearSolenoid", gearBasefloorGearSolenoid);
        
        gearBaserotatGearSolenoid = new DoubleSolenoid(1, 4, 5);
        LiveWindow.addActuator("GearBase", "rotatGearSolenoid", gearBaserotatGearSolenoid);
        
        climberBaseclimberSolenoid = new DoubleSolenoid(1, 2, 3);
        LiveWindow.addActuator("ClimberBase", "climberSolenoid", climberBaseclimberSolenoid);
        

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS

		// There are 2 driver motors on each side of the robot.
		// Here is the mapping for the left.
		driveBaseLeftTalon1 = new CANTalon(2); // these are the main two talons
		driveBaseRightTalon1 = new CANTalon(4);

		// these next two are slaved to the first two
		driveBaseLeftTalon2 = new CANTalon(3);
		driveBaseRightTalon2 = new CANTalon(5);

		// talon for the climber
		driveBaseClimberTalon = new CANTalon(6);
		lifterTalon = new CANTalon(7); // talon for lifter
		GearIntakeTalon = new CANTalon(8); //talon to intake gear from the floor

		// change modes
		driveBaseLeftTalon1.changeControlMode(TalonControlMode.Speed); // speed
																		// is
																		// for
																		// encoders
		
		driveBaseRightTalon1.changeControlMode(TalonControlMode.Speed); // changed
																		// from
																		// PercentVbus
		
		driveBaseLeftTalon2.changeControlMode(TalonControlMode.Follower);
		driveBaseRightTalon2.changeControlMode(TalonControlMode.Follower);

		// indicate which talons the followers are following
		driveBaseLeftTalon2.set(2); // talon 3 is following talon 2
		driveBaseRightTalon2.set(4); // talon 5 is following talon 4

		// set feedback device native resolution to 4096
		driveBaseLeftTalon1.setFeedbackDevice(FeedbackDevice.QuadEncoder);
		;
		driveBaseRightTalon1.setFeedbackDevice(FeedbackDevice.QuadEncoder);
		;
		
		//quadrature encoder can tell direction
		//pulses per revolution tells distance
		//number of revolutions divided by 2048 pulses per one revolution 
		//multiplied by circumference of the wheel gives distance traveled
		
		
		driveBaseLeftTalon1.configEncoderCodesPerRev(2048); // pulses per
															// revolution
		driveBaseRightTalon1.configEncoderCodesPerRev(2048); // pulses per
																// revolution

		// set PID parameters
		driveBaseLeftTalon1.setPID(.05, 0, 0); //why is there PID stuff here??!
		driveBaseRightTalon1.setPID(.05, 0, 0);
		driveBaseLeftTalon1.setF(.125680591); // changed to 0.12 based on f-gain
												// calculations
		driveBaseRightTalon1.setF(.125680591); // changed to 0.12 based on
												// f-gain calculations

		//f-gain calculations: multiply pulses per revolution (2048) by revolutions per 
		//minute (1366) to get pulses per minute. Then divide pulses per minute by 
		//600 because you want 100ms intervals. Then divide 568 by what you get. Answer is f-term. 
		//f-gain multiplied by pulses per 100ms = max speed
		//EQUATION: f * ((2048 * 1366)/600) = 586   ~solve for f
		
		//f-gain makes sure that full motor output is calculated when requested speed is 4,662 pulses
		//per 100ms. Makes sure there is proportional motor output to the pulses set by the talon.
		
		
		//set nominal/peak outputs voltage
		driveBaseLeftTalon1.configNominalOutputVoltage(+0.0f, -0.0f);
		driveBaseRightTalon1.configNominalOutputVoltage(+0.0f, -0.0f);
		driveBaseLeftTalon1.configPeakOutputVoltage(+12.0f, -12.0f);
		driveBaseRightTalon1.configPeakOutputVoltage(+12.0f, -12.0f);

		ahrs = new AHRS(I2C.Port.kMXP, (byte) 100); // the navX!!
		LiveWindow.addSensor("Drive Subsystem", "navX", ahrs);

	}
}
