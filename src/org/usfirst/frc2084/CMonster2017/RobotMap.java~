// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc2084.CMonster2017;

import org.usfirst.frc2084.CMonster2017.PID.DistancePID;
import org.usfirst.frc2084.CMonster2017.PID.HeadingPID;
import org.usfirst.frc2084.CMonster2017.RobotMap;
import org.usfirst.frc2084.CMonster2017.commands.*;
import edu.wpi.first.wpilibj.CounterBase.EncodingType;
import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.PIDController;
import edu.wpi.first.wpilibj.PIDSourceType;
import edu.wpi.first.wpilibj.Spark;
import edu.wpi.first.wpilibj.SpeedController;
import com.ctre.CANTalon.FeedbackDevice;
import com.ctre.CANTalon.TalonControlMode;
import edu.wpi.first.wpilibj.command.Subsystem;
import com.ctre.*;

import com.kauailabs.navx.frc.AHRS;
import edu.wpi.first.wpilibj.I2C;

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import edu.wpi.first.wpilibj.Compressor;
import edu.wpi.first.wpilibj.DoubleSolenoid;

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

/**
 * The RobotMap is a mapping from the ports sensors and actuators are wired into
 * to a variable name. This provides flexibility changing wiring, makes checking
 * the wiring easier and significantly reduces the number of magic numbers
 * floating around.
 */
public class RobotMap {
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	public static Compressor gearBaseCompressor;
	public static DoubleSolenoid gearBasegearSolenoid;
	public static DoubleSolenoid climberBaseclimberSolenoid;
	public static DoubleSolenoid intakeBaseInOutSolenoid;
	public static DoubleSolenoid intakeBasegateSolenoid;

	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

	// autogenerated code declares all the solenoids and the compressor

	public static DistancePID distancePID = new DistancePID(); // PID for
																// distance -
																// makes the
																// robot slow
																// down at the
																// right times,
																// keeps
																// straight
																// course
	
	public static HeadingPID headingPID = new HeadingPID(); // PID for
															// controlling the
															// direction of he
															// robot
	
	public static double AverageDistance; // the average of right and left
											// distance from encoders

	// There are 2 driver motors on each side of the robot.
	// Here are the declarations.
	// public static SpeedController driveBasePIDLeftTalon2;
	// public static SpeedController driveBasePIDRightTanlon2;
	// public static PIDController driveBasePIDLeftPIDController2;
	// public static PIDController driveBasePIDRightPIDController2;

	public static AHRS ahrs; // navX

	public static CANTalon driveBaseLeftTalon1; // main
	public static CANTalon driveBaseRightTalon1; // main
	public static CANTalon driveBaseLeftTalon2; // followers
	public static CANTalon driveBaseRightTalon2; // followers

	public static CANTalon driveBaseClimberTalon; // Talon for the climber
	public static CANTalon lifterTalon; // talon for the climber

	/**
	 * .0 Wheel diameter in feet.
	 */
	public static final double DRIVE_SUBSYSTEM_WHEEL_DIAMETER = 0.33333333333; 
	//0.3333333 is 1/3 of a foot, or 4 inches (the diameter of the wheels)
	
	public static final double DRIVE_SUBSYSTEM_BELT_RATIO = 1 / 1; // no belt
																	// ratio
	public static final double DISTANCE_PER_PULSE = Math.PI * 0.333333333333; // 1.047166666666
	// pi times the diameter is the circumfrence of the wheel - how far it goes
	// with each rotation

	/**
	 * The navX Micro used for autonomous and aiming
	 */

	public static void init() {
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
		gearBaseCompressor = new Compressor(1);

		gearBasegearSolenoid = new DoubleSolenoid(1, 0, 1);
		LiveWindow.addActuator("GearBase", "gearSolenoid", gearBasegearSolenoid);

		climberBaseclimberSolenoid = new DoubleSolenoid(1, 2, 3);
		LiveWindow.addActuator("ClimberBase", "climberSolenoid", climberBaseclimberSolenoid);

		intakeBaseInOutSolenoid = new DoubleSolenoid(1, 4, 5);
		LiveWindow.addActuator("IntakeBase", "InOutSolenoid", intakeBaseInOutSolenoid);

		intakeBasegateSolenoid = new DoubleSolenoid(1, 6, 7);
		LiveWindow.addActuator("IntakeBase", "gateSolenoid", intakeBasegateSolenoid);

		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS

		// There are 2 driver motors on each side of the robot.
		// Here is the mapping for the left.
		driveBaseLeftTalon1 = new CANTalon(2); // these are the main two talons
		driveBaseRightTalon1 = new CANTalon(4);

		// these next two are slaved to the first two
		driveBaseLeftTalon2 = new CANTalon(3);
		driveBaseRightTalon2 = new CANTalon(5);

		// talon for the climber
		driveBaseClimberTalon = new CANTalon(6);
		lifterTalon = new CANTalon(7); // talon for lifter

		// change modes
		driveBaseLeftTalon1.changeControlMode(TalonControlMode.Speed); // speed
																		// is
																		// for
																		// encoders
		
		driveBaseRightTalon1.changeControlMode(TalonControlMode.Speed); // changed
																		// from
																		// PercentVbus
		
		driveBaseLeftTalon2.changeControlMode(TalonControlMode.Follower);
		driveBaseRightTalon2.changeControlMode(TalonControlMode.Follower);

		// indicate which talons the followers are following
		driveBaseLeftTalon2.set(2); // talon 3 is following talon 2
		driveBaseRightTalon2.set(4); // talon 5 is following talon 4

		// set feedback device native resolution to 4096
		driveBaseLeftTalon1.setFeedbackDevice(FeedbackDevice.QuadEncoder);
		;
		driveBaseRightTalon1.setFeedbackDevice(FeedbackDevice.QuadEncoder);
		;
		
		
		driveBaseLeftTalon1.configEncoderCodesPerRev(2048); // pulses per
															// revolution
		driveBaseRightTalon1.configEncoderCodesPerRev(2048); // pulses per
																// revolution

		// set PID parameters
		driveBaseLeftTalon1.setPID(.05, 0, 0);
		driveBaseRightTalon1.setPID(.05, 0, 0);
		driveBaseLeftTalon1.setF(.125680591); // changed to 0.12 based on f-gain
												// calculations
		driveBaseRightTalon1.setF(.125680591); // changed to 0.12 based on
												// f-gain calculations

		// set nominal/peak outputs voltage
		driveBaseLeftTalon1.configNominalOutputVoltage(+0.0f, -0.0f);
		driveBaseRightTalon1.configNominalOutputVoltage(+0.0f, -0.0f);
		driveBaseLeftTalon1.configPeakOutputVoltage(+12.0f, -12.0f);
		driveBaseRightTalon1.configPeakOutputVoltage(+12.0f, -12.0f);

		ahrs = new AHRS(I2C.Port.kMXP, (byte) 100); // the navX
		LiveWindow.addSensor("Drive Subsystem", "navX", ahrs);

		// driveBaseLeftEncoder.setDistancePerPulse(DRIVE_SUBYSTEM_ENCODER_DISTANCE_PER_PULSE);
		// driveBaseRightEncoder.setDistancePerPulse(DRIVE_SUBYSTEM_ENCODER_DISTANCE_PER_PULSE);

	}
}
