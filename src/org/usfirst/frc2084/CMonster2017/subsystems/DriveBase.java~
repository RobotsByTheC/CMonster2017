// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc2084.CMonster2017.subsystems;

import org.usfirst.frc2084.CMonster2017.RobotMap;
import org.usfirst.frc2084.CMonster2017.Drive.ArcadeDrive;
import org.usfirst.frc2084.CMonster2017.PID.DistancePID;
import org.usfirst.frc2084.CMonster2017.PID.HeadingPID;
import org.usfirst.frc2084.CMonster2017.commands.*;

import com.kauailabs.navx.frc.AHRS;



import edu.wpi.first.wpilibj.CounterBase.EncodingType;
import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.PIDController;
import edu.wpi.first.wpilibj.PIDSourceType;
import edu.wpi.first.wpilibj.SpeedController;
import edu.wpi.first.wpilibj.Talon;
import edu.wpi.first.wpilibj.smartdashboard.*;

import edu.wpi.first.wpilibj.command.Subsystem;

/**
 *
 */
public class DriveBase extends Subsystem {

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private final SpeedController leftTalon1 = RobotMap.driveBaseLeftTalon1;
    private final Encoder leftEncoder = RobotMap.driveBaseLeftEncoder;
    private final PIDController leftPIDController1 = RobotMap.driveBaseLeftPIDController1;
    private final SpeedController rightTanlon1 = RobotMap.driveBaseRightTanlon1;
    private final Encoder rightEncoder = RobotMap.driveBaseRightEncoder;
    private final PIDController rightPIDController1 = RobotMap.driveBaseRightPIDController1;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
      private final AHRS ahrs = RobotMap.ahrs;  
      
      
      // There are 2 driver motors on each side of the robot. 
      // Here are the declarations.
     private final SpeedController leftTalon2 = RobotMap.driveBasePIDLeftTalon2;
     private final PIDController leftPIDController2 = RobotMap.driveBasePIDLeftPIDController2;
     private final SpeedController rightTanlon2 = RobotMap.driveBasePIDRightTanlon2;
     private final PIDController rightPIDController2 = RobotMap.driveBasePIDRightPIDController2;
      
    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    

    double leftMotorSpeed;  // variables used to calculate motor speed
    double rightMotorSpeed;
    double moveSpeed;
    double rotateSpeed;
    
    boolean InPosition;     // variables for autonomous
    double LeftDistance;    
    double RightDistance;
    int Waypoint = 1;              // the number of way points stating at 1.
    double [] WayPoints = new double[3];  // array with 3 elements holding the distance to each way point;
    ArcadeDrive arcadeDrive = new ArcadeDrive();
   double[] returnData = new double[2];
   
    
    
    HeadingPID headingPID = RobotMap.headingPID;  //instance variables 
    DistancePID distancePID = RobotMap.distancePID;
    

    public void EnableDriveBase() {
    	leftPIDController1.reset();  //reset PID controllers before enable to prevent "wind up"
    	rightPIDController1.reset();
    	leftPIDController2.reset();
    	rightPIDController2.reset();
    	
    	leftEncoder.reset();
    	rightEncoder.reset();
    	
    	leftPIDController1.enable(); // Enable PID controllers. 
    	rightPIDController1.enable();
    	leftPIDController2.enable(); 
      	rightPIDController2.enable();
       	}
    	
    public void DisableDriveBase() {
    	leftPIDController1.disable();   //Disable PID controllers.
    	rightPIDController1.disable();
    	leftPIDController2.disable();  
    	rightPIDController2.disable();
    	}
    
    
    
	
    public void DriveAutonomous (){
    	
    	moveSpeed = distancePID.getOutput();
    	rotateSpeed = headingPID.getOutput();  //Get and store the output from the heading PID controller.
    	
    	
    	SmartDashboard.putNumber("HeadingPID", rotateSpeed);//rotateSpeed is the value of HeadingPID
   SmartDashboard.putNumber("YAW", (double)ahrs.getYaw());
   SmartDashboard.putNumber("DistancePID", moveSpeed);
//   SmartDashboard.putNumber("pitch", (double)ahrs.getPitch());
 //  SmartDashboard.putNumber("roll", (double)ahrs.getRoll());
    	
   returnData = arcadeDrive.calculateSpeed(moveSpeed, rotateSpeed);
   leftMotorSpeed = returnData[0];
   rightMotorSpeed = returnData[1];
   //these 3 lines replace the arcade calculations blocks, call them from ArchadeDrive class
   
   
        // Drive the left and right sides of the robot at the specified speeds.
    	rightPIDController1.setSetpoint(rightMotorSpeed);
    	leftPIDController1.setSetpoint(leftMotorSpeed); 
    	rightPIDController2.setSetpoint(rightMotorSpeed);
    	leftPIDController2.setSetpoint(leftMotorSpeed); 
    	
    
    	LeftDistance = leftEncoder.getDistance();    //Read encoder distance traveled in meters.
    	RightDistance = rightEncoder.getDistance();
    	//have to invert rightDistance so the average isn't negative
    	RightDistance *= -1;
    	RobotMap.AverageDistance = (LeftDistance + (RightDistance)) / 2;  // Calculate the average distance traveled.
    	
    			
    	SmartDashboard.putNumber("Left Distance", LeftDistance);   
    	SmartDashboard.putNumber("Right Distance", RightDistance);
    	SmartDashboard.putNumber("AV Distance", RobotMap.AverageDistance);
    	//SmartDashboard.putNumber("HeadingPID", headingPID.getOutput());
    	
    	
    	}
    
    
 
  //method called during teleop from DriveWithJoystick command. executes arcade drive algorithm using joy stick inputs.
    public void JoystickInputs(Joystick stick){ //teleop method
    	
    	moveSpeed = stick.getY() * -1; // set variables = Joystick inputs 
    	//invert the y value to -1 so that pushing the joystick forward gives a positive value
    	rotateSpeed = stick.getX() * -1; //also invert the x value so right/left aren't inverted
    	
    	returnData = arcadeDrive.calculateSpeed(moveSpeed, rotateSpeed);
    	
   
    	 
    	leftMotorSpeed = returnData[0];
    	rightMotorSpeed = returnData[1];
        
        //leftMotorSpeed *= -1; // invert motor speed command.

        // Drive the left and right sides of the robot at the specified speeds.
    	rightPIDController1.setSetpoint(rightMotorSpeed);
    	leftPIDController1.setSetpoint(leftMotorSpeed);
    	rightPIDController2.setSetpoint(rightMotorSpeed);
    	leftPIDController2.setSetpoint(leftMotorSpeed); 
    	
    	
    	SmartDashboard.putNumber("LeftPID", leftMotorSpeed);
    	SmartDashboard.putNumber("RightPID", rightMotorSpeed);
    	
    
    }	 

    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        setDefaultCommand(new DriveWithJoystick());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }
}
